{"ast":null,"code":"export function getTranslateValues(element) {\n  const style = window.getComputedStyle(element);\n  const matrix = style[\"transform\"] || style.webkitTransform || style.mozTransform; // No transform property. Simply return 0 values.\n\n  if (matrix === \"none\" || typeof matrix === \"undefined\") {\n    return {\n      x: 0,\n      y: 0,\n      z: 0\n    };\n  } // Can either be 2d or 3d transform\n\n\n  const matrixType = matrix.includes(\"3d\") ? \"3d\" : \"2d\";\n  const matrixValues = matrix.match(/matrix.*\\((.+)\\)/)[1].split(\", \"); // 2d matrices have 6 values\n  // Last 2 values are X and Y.\n  // 2d matrices does not have Z value.\n\n  if (matrixType === \"2d\") {\n    return {\n      x: matrixValues[4],\n      y: matrixValues[5],\n      z: 0\n    };\n  } // 3d matrices have 16 values\n  // The 13th, 14th, and 15th values are X, Y, and Z\n\n\n  if (matrixType === \"3d\") {\n    return {\n      x: matrixValues[12],\n      y: matrixValues[13],\n      z: matrixValues[14]\n    };\n  }\n}\nexport const movePlateUp = _ref => {\n  let {\n    currentTimeStamp,\n    start,\n    previousTimeStamp,\n    fromTowerRef,\n    requestId,\n    doneMoveUpCallback\n  } = _ref;\n  const plate = fromTowerRef && fromTowerRef.querySelector(\".plate-track\");\n  if (!plate) return;\n  const maxHeight = fromTowerRef.offsetHeight - (fromTowerRef.childElementCount - 1) * 13;\n  if (start === undefined) start = currentTimeStamp;\n  const elapsed = currentTimeStamp - start;\n\n  if (previousTimeStamp !== currentTimeStamp) {\n    const count = Math.min(0.7 * elapsed, maxHeight);\n    plate.style.transform = \"translateY(\" + -count + \"px)\";\n\n    if (count < maxHeight) {\n      previousTimeStamp = currentTimeStamp;\n      requestId = window.requestAnimationFrame(timeStamp => {\n        movePlateUp({\n          currentTimeStamp: timeStamp,\n          start,\n          previousTimeStamp,\n          fromTowerRef,\n          requestId,\n          doneMoveUpCallback\n        });\n      });\n    } else {\n      start = previousTimeStamp;\n      doneMoveUpCallback && doneMoveUpCallback();\n    }\n  }\n};\nexport const movePlateHorizontal = _ref2 => {\n  let {\n    currentTimeStamp,\n    start,\n    previousTimeStamp,\n    fromTowerRef,\n    toTowerRef,\n    requestId,\n    doneMoveHorizontalCallback\n  } = _ref2;\n  const plate = fromTowerRef && fromTowerRef.querySelector(\".plate-track\");\n  if (!plate) return;\n  const distanceDiff = fromTowerRef.getBoundingClientRect().left - toTowerRef.getBoundingClientRect().left;\n  if (start === undefined) start = currentTimeStamp;\n  const elapsed = currentTimeStamp - start;\n\n  if (previousTimeStamp !== currentTimeStamp) {\n    var _getTranslateValues;\n\n    let count = Math.min(0.5 * elapsed, Math.abs(distanceDiff));\n    count = distanceDiff > 0 ? -count : count;\n    const previousTranslateY = (_getTranslateValues = getTranslateValues(plate)) === null || _getTranslateValues === void 0 ? void 0 : _getTranslateValues.y;\n    plate.style.transform = `translate(${count}px, ${previousTranslateY}px)`;\n\n    if (Math.abs(count) < Math.abs(distanceDiff)) {\n      previousTimeStamp = currentTimeStamp;\n      requestId = window.requestAnimationFrame(timeStamp => {\n        movePlateHorizontal({\n          currentTimeStamp: timeStamp,\n          start,\n          previousTimeStamp,\n          fromTowerRef,\n          toTowerRef,\n          requestId,\n          doneMoveHorizontalCallback\n        });\n      });\n    } else {\n      start = previousTimeStamp;\n      doneMoveHorizontalCallback && doneMoveHorizontalCallback();\n    }\n  }\n};\nexport const movePlateDown = _ref3 => {\n  let {\n    currentTimeStamp,\n    start,\n    previousTimeStamp,\n    fromTowerRef,\n    toTowerRef,\n    requestId,\n    doneMoveDownCallback\n  } = _ref3;\n  const plate = fromTowerRef && fromTowerRef.querySelector(\".plate-track\");\n  if (!plate) return;\n  const maxDistanceToMove = toTowerRef.offsetHeight - toTowerRef.childElementCount * 13;\n  if (start === undefined) start = currentTimeStamp;\n  const elapsed = currentTimeStamp - start;\n\n  if (previousTimeStamp !== currentTimeStamp) {\n    var _getTranslateValues2;\n\n    let count = 0.7 * elapsed;\n    count = count <= maxDistanceToMove ? count : maxDistanceToMove;\n    const previousTranslateX = (_getTranslateValues2 = getTranslateValues(plate)) === null || _getTranslateValues2 === void 0 ? void 0 : _getTranslateValues2.x;\n    let finalTranslateY = -toTowerRef.offsetHeight + 13 + 13 + count + (fromTowerRef.childElementCount - 3) * 13;\n\n    if (fromTowerRef === toTowerRef) {\n      finalTranslateY = finalTranslateY + 13;\n    }\n\n    plate.style.transform = `translate(${previousTranslateX}px, ${finalTranslateY}px)`;\n\n    if (count < maxDistanceToMove) {\n      previousTimeStamp = currentTimeStamp;\n      requestId = window.requestAnimationFrame(timeStamp => {\n        movePlateDown({\n          currentTimeStamp: timeStamp,\n          start,\n          previousTimeStamp,\n          fromTowerRef,\n          toTowerRef,\n          requestId,\n          doneMoveDownCallback\n        });\n      });\n    } else {\n      doneMoveDownCallback && doneMoveDownCallback();\n    }\n  }\n};","map":{"version":3,"sources":["/Users/apple/the-tower/src/utils.js"],"names":["getTranslateValues","element","style","window","getComputedStyle","matrix","webkitTransform","mozTransform","x","y","z","matrixType","includes","matrixValues","match","split","movePlateUp","currentTimeStamp","start","previousTimeStamp","fromTowerRef","requestId","doneMoveUpCallback","plate","querySelector","maxHeight","offsetHeight","childElementCount","undefined","elapsed","count","Math","min","transform","requestAnimationFrame","timeStamp","movePlateHorizontal","toTowerRef","doneMoveHorizontalCallback","distanceDiff","getBoundingClientRect","left","abs","previousTranslateY","movePlateDown","doneMoveDownCallback","maxDistanceToMove","previousTranslateX","finalTranslateY"],"mappings":"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","sourcesContent":["export function getTranslateValues(element) {\n    const style = window.getComputedStyle(element);\n    const matrix =\n      style[\"transform\"] || style.webkitTransform || style.mozTransform;\n  \n    // No transform property. Simply return 0 values.\n    if (matrix === \"none\" || typeof matrix === \"undefined\") {\n      return {\n        x: 0,\n        y: 0,\n        z: 0\n      };\n    }\n  \n    // Can either be 2d or 3d transform\n    const matrixType = matrix.includes(\"3d\") ? \"3d\" : \"2d\";\n    const matrixValues = matrix.match(/matrix.*\\((.+)\\)/)[1].split(\", \");\n  \n    // 2d matrices have 6 values\n    // Last 2 values are X and Y.\n    // 2d matrices does not have Z value.\n    if (matrixType === \"2d\") {\n      return {\n        x: matrixValues[4],\n        y: matrixValues[5],\n        z: 0\n      };\n    }\n  \n    // 3d matrices have 16 values\n    // The 13th, 14th, and 15th values are X, Y, and Z\n    if (matrixType === \"3d\") {\n      return {\n        x: matrixValues[12],\n        y: matrixValues[13],\n        z: matrixValues[14]\n      };\n    }\n  }\n  \n  export const movePlateUp = ({\n    currentTimeStamp,\n    start,\n    previousTimeStamp,\n    fromTowerRef,\n    requestId,\n    doneMoveUpCallback\n  }) => {\n    const plate = fromTowerRef && fromTowerRef.querySelector(\".plate-track\");\n  \n    if (!plate) return;\n  \n    const maxHeight =\n      fromTowerRef.offsetHeight - (fromTowerRef.childElementCount - 1) * 13;\n    if (start === undefined) start = currentTimeStamp;\n    const elapsed = currentTimeStamp - start;\n  \n    if (previousTimeStamp !== currentTimeStamp) {\n      const count = Math.min(0.7 * elapsed, maxHeight);\n      plate.style.transform = \"translateY(\" + -count + \"px)\";\n  \n      if (count < maxHeight) {\n        previousTimeStamp = currentTimeStamp;\n        requestId = window.requestAnimationFrame((timeStamp) => {\n          movePlateUp({\n            currentTimeStamp: timeStamp,\n            start,\n            previousTimeStamp,\n            fromTowerRef,\n            requestId,\n            doneMoveUpCallback\n          });\n        });\n      } else {\n        start = previousTimeStamp;\n        doneMoveUpCallback && doneMoveUpCallback();\n      }\n    }\n  };\n  \n  export const movePlateHorizontal = ({\n    currentTimeStamp,\n    start,\n    previousTimeStamp,\n    fromTowerRef,\n    toTowerRef,\n    requestId,\n    doneMoveHorizontalCallback\n  }) => {\n    const plate = fromTowerRef && fromTowerRef.querySelector(\".plate-track\");\n  \n    if (!plate) return;\n  \n    const distanceDiff =\n      fromTowerRef.getBoundingClientRect().left -\n      toTowerRef.getBoundingClientRect().left;\n  \n    if (start === undefined) start = currentTimeStamp;\n    const elapsed = currentTimeStamp - start;\n  \n    if (previousTimeStamp !== currentTimeStamp) {\n      let count = Math.min(0.5 * elapsed, Math.abs(distanceDiff));\n  \n      count = distanceDiff > 0 ? -count : count;\n  \n      const previousTranslateY = getTranslateValues(plate)?.y;\n      plate.style.transform = `translate(${count}px, ${previousTranslateY}px)`;\n  \n      if (Math.abs(count) < Math.abs(distanceDiff)) {\n        previousTimeStamp = currentTimeStamp;\n        requestId = window.requestAnimationFrame((timeStamp) => {\n          movePlateHorizontal({\n            currentTimeStamp: timeStamp,\n            start,\n            previousTimeStamp,\n            fromTowerRef,\n            toTowerRef,\n            requestId,\n            doneMoveHorizontalCallback\n          });\n        });\n      } else {\n        start = previousTimeStamp;\n        doneMoveHorizontalCallback && doneMoveHorizontalCallback();\n      }\n    }\n  };\n  \n  export const movePlateDown = ({\n    currentTimeStamp,\n    start,\n    previousTimeStamp,\n    fromTowerRef,\n    toTowerRef,\n    requestId,\n    doneMoveDownCallback\n  }) => {\n    const plate = fromTowerRef && fromTowerRef.querySelector(\".plate-track\");\n    if (!plate) return;\n    const maxDistanceToMove =\n      toTowerRef.offsetHeight - toTowerRef.childElementCount * 13;\n    if (start === undefined) start = currentTimeStamp;\n    const elapsed = currentTimeStamp - start;\n    if (previousTimeStamp !== currentTimeStamp) {\n      let count = 0.7 * elapsed;\n      count = count <= maxDistanceToMove ? count : maxDistanceToMove;\n  \n      const previousTranslateX = getTranslateValues(plate)?.x;\n  \n      let finalTranslateY =\n        -toTowerRef.offsetHeight +\n        13 +\n        13 +\n        count +\n        (fromTowerRef.childElementCount - 3) * 13;\n  \n      if (fromTowerRef === toTowerRef) {\n        finalTranslateY = finalTranslateY + 13;\n      }\n  \n      plate.style.transform = `translate(${previousTranslateX}px, ${finalTranslateY}px)`;\n  \n      if (count < maxDistanceToMove) {\n        previousTimeStamp = currentTimeStamp;\n        requestId = window.requestAnimationFrame((timeStamp) => {\n          movePlateDown({\n            currentTimeStamp: timeStamp,\n            start,\n            previousTimeStamp,\n            fromTowerRef,\n            toTowerRef,\n            requestId,\n            doneMoveDownCallback\n          });\n        });\n      } else {\n        doneMoveDownCallback && doneMoveDownCallback();\n      }\n    }\n  };"]},"metadata":{},"sourceType":"module"}